<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>二、编写第一个单元测试</title>
    <link href="/2020/12/29/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%EF%BC%9A%E4%BA%8C%E3%80%81%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <url>/2020/12/29/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%EF%BC%9A%E4%BA%8C%E3%80%81%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="二、编写第一个单元测试"><a href="#二、编写第一个单元测试" class="headerlink" title="二、编写第一个单元测试"></a>二、编写第一个单元测试</h1><p><a name="ylQwH"></a></p><h2 id="使用XUnit-net测试框架的代码结构"><a href="#使用XUnit-net测试框架的代码结构" class="headerlink" title="使用XUnit.net测试框架的代码结构"></a>使用XUnit.net测试框架的代码结构</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/10356904/1609919105076-cbc6110a-f67f-4fa8-a78b-b090e1adf6ed.png#align=left&display=inline&height=384&margin=%5Bobject%20Object%5D&name=Xunit.NET%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84.png&originHeight=384&originWidth=1195&size=22453&status=done&style=none&width=1195" alt="Xunit.NET项目架构.png"><br />测试项目需引用被项目从而对其进行测试，测试项目同时需要引用xUnit库。<br />测试编写好后，用Test Runner来运行测试。Test Runner可以读取测试代码，并且会知道我们所使用的测试框架，然后执行，并显示结果。<br />目前可用的Test Runner包括vs自带的Test Explorer，或者dotnet core命令行，以及第三方工具，例如resharper等等。<br><a name="XHFIS"></a></p><h3 id="xUnit支持的平台："><a href="#xUnit支持的平台：" class="headerlink" title="xUnit支持的平台："></a>xUnit支持的平台：</h3><p>.net framework, .net core, .net standard, uwp, xamarin.<br><a name="qtKc3"></a></p><h2 id="创建一个被测试项目"><a href="#创建一个被测试项目" class="headerlink" title="创建一个被测试项目"></a>创建一个被测试项目</h2><p>我们用一个.NET Standard 类库来作为被测试项目<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/10356904/1609919451207-cf5c37a4-d904-4078-9fd4-ba28e18bed54.png#align=left&display=inline&height=680&margin=%5Bobject%20Object%5D&name=image.png&originHeight=680&originWidth=1024&size=74470&status=done&style=none&width=1024" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2021/png/10356904/1609924399266-8b77265f-9bf8-47db-b6a4-068860761c60.png#align=left&display=inline&height=680&margin=%5Bobject%20Object%5D&name=image.png&originHeight=680&originWidth=1024&size=33911&status=done&style=none&width=1024" alt="image.png"><br />建一个Calculator类，并添加一个Add的Public方法。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/10356904/1609924599762-acbd75ff-d326-4326-a335-51edb21a106b.png#align=left&display=inline&height=995&margin=%5Bobject%20Object%5D&name=image.png&originHeight=995&originWidth=1905&size=147148&status=done&style=none&width=1905" alt="image.png"><br><a name="amkPz"></a></p><h2 id="创建对应的测试项目"><a href="#创建对应的测试项目" class="headerlink" title="创建对应的测试项目"></a>创建对应的测试项目</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/10356904/1609924751905-e7e7918e-7696-472d-86bb-1499531771d4.png#align=left&display=inline&height=680&margin=%5Bobject%20Object%5D&name=image.png&originHeight=680&originWidth=1024&size=75564&status=done&style=none&width=1024" alt="image.png"><br />一般情况，我们将测试项目名称定义为被测试项目加上 .Test。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/10356904/1609924863682-391530e2-ffd8-4346-a3e8-101da63a5ce0.png#align=left&display=inline&height=1014&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1014&originWidth=1884&size=164174&status=done&style=none&width=1884" alt="image.png"><br />可以看到，Visual Studio已经帮我们建立好了一个测试类，并且相应的XUnit测试框架已经被引用进来。<br />添加目标项目的引用。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/10356904/1609925113806-361b8554-3065-422e-9522-4e58a5d4fcfe.png#align=left&display=inline&height=550&margin=%5Bobject%20Object%5D&name=image.png&originHeight=550&originWidth=800&size=27321&status=done&style=none&width=800" alt="image.png"><br />我们重构一下代码。   </p><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<span class="hljs-keyword">using</span> Xunit;<span class="hljs-keyword">namespace</span> <span class="hljs-title">XUnitPracticeDemo.Test</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CalculatorTest</span>    &#123;        [<span class="hljs-meta">Fact</span>]        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ShouldAdd</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>        &#123;            <span class="hljs-comment">// Arrange</span>            <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;            <span class="hljs-keyword">var</span> y = <span class="hljs-number">2</span>;            <span class="hljs-keyword">var</span> sut = <span class="hljs-keyword">new</span> Calculator(); <span class="hljs-comment">// system under test</span>            <span class="hljs-comment">// Act</span>            <span class="hljs-keyword">var</span> result = sut.Add(x, y);            <span class="hljs-comment">// Assert</span>            Assert.Equal(<span class="hljs-number">3</span>, result);        &#125;    &#125;&#125;</code></pre><p>一个单元测试主要包含三个行为<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/10356904/1609925708184-30a4108f-3ea9-4a4a-9ee1-a17382d02293.png#align=left&display=inline&height=610&margin=%5Bobject%20Object%5D&name=%E4%B8%89A.png&originHeight=610&originWidth=336&size=9136&status=done&style=none&width=336" alt="三A.png"></p><ol><li>准备（Arrange）对象，创建对象，进行必要的设置；</li><li>操作（Act）对象；执行生产代码并返回结果。例如调用方法，或者设置属性（Properties）。</li><li>断言（Assert）某件事情是预期的。</li></ol><p><br />我们试着运行一下测试<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/10356904/1609925428026-57cf4231-6537-44aa-95d6-b1b4a0f2dab9.png#align=left&display=inline&height=224&margin=%5Bobject%20Object%5D&name=image.png&originHeight=224&originWidth=419&size=17219&status=done&style=none&width=419" alt="image.png"><br />在测试资源管理器中可以看到测试结果。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/10356904/1609925569953-04ff6306-476f-497f-8e42-fceffcbdb234.png#align=left&display=inline&height=322&margin=%5Bobject%20Object%5D&name=image.png&originHeight=322&originWidth=1389&size=35044&status=done&style=none&width=1389" alt="image.png"><br />测试不通过的情况是这样的。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/10356904/1609925982284-63f41538-062f-466c-bb97-40e29610f12f.png#align=left&display=inline&height=326&margin=%5Bobject%20Object%5D&name=image.png&originHeight=326&originWidth=1845&size=51384&status=done&style=none&width=1845" alt="image.png"><br><a name="p2ANz"></a></p><h2 id="Visual-Studio-Community-2019提供的特性"><a href="#Visual-Studio-Community-2019提供的特性" class="headerlink" title="Visual Studio Community 2019提供的特性"></a>Visual Studio Community 2019提供的特性</h2><p>单个测试的执行<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/10356904/1609926865905-ba66f7d0-429f-4bde-b326-45b53d6c0be5.png#align=left&display=inline&height=796&margin=%5Bobject%20Object%5D&name=image.png&originHeight=796&originWidth=1141&size=117957&status=done&style=none&width=1141" alt="image.png"><br />被测试方法的上一次测试情况<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/10356904/1609926913393-4cf1e320-f99b-4413-ba09-21e556b295db.png#align=left&display=inline&height=652&margin=%5Bobject%20Object%5D&name=image.png&originHeight=652&originWidth=1150&size=67447&status=done&style=none&width=1150" alt="image.png"><br />测试的分类<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/10356904/1609927030440-6bb45aa6-53fc-4cb3-9e91-f3fac67b148e.png#align=left&display=inline&height=642&margin=%5Bobject%20Object%5D&name=image.png&originHeight=642&originWidth=532&size=40823&status=done&style=none&width=532" alt="image.png"><br><a name="CRV3H"></a></p><h2 id="使用DotNet-CLI进行测试"><a href="#使用DotNet-CLI进行测试" class="headerlink" title="使用DotNet CLI进行测试"></a>使用DotNet CLI进行测试</h2><p>我们用命令行打开测试项目的根目录<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/10356904/1609927227651-8408e921-4510-4f14-ae36-7f4dcd96a124.png#align=left&display=inline&height=631&margin=%5Bobject%20Object%5D&name=image.png&originHeight=631&originWidth=1129&size=37636&status=done&style=none&width=1129" alt="image.png"><br />执行命令：</p><pre><code class="hljs bash">dotnet <span class="hljs-built_in">test</span></code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/10356904/1609927301818-dfa2f4ce-5fb2-44eb-abdf-d2f93bf4a770.png#align=left&display=inline&height=631&margin=%5Bobject%20Object%5D&name=image.png&originHeight=631&originWidth=1129&size=75928&status=done&style=none&width=1129" alt="image.png"><br />下一篇，我们将详细介绍一下XUnit.Net中的Assert断言的使用。</p>]]></content>
    
    
    <categories>
      
      <category>学习计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单元测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一、单元测试的基本知识</title>
    <link href="/2020/12/29/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%EF%BC%9A%E4%B8%80%E3%80%81%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    <url>/2020/12/29/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%EF%BC%9A%E4%B8%80%E3%80%81%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="一、单元测试的基本知识"><a href="#一、单元测试的基本知识" class="headerlink" title="一、单元测试的基本知识"></a>一、单元测试的基本知识</h1><p><a name="qxLMH"></a></p><h2 id="什么是单元测试"><a href="#什么是单元测试" class="headerlink" title="什么是单元测试"></a>什么是单元测试</h2><blockquote><p>一个单元测试是一段自动化的代码。<br>这段代码调用被测试的工作单元，之后对这个工作单元的单个最终结果的某些假设进行检验。<br>单元测试几乎都是用单元测试框架编写的。<br>单元测试容易编写，能快速运行。<br>单元测试可靠，可读，并且可维护。<br>只要产品代码不发生变化，单元测试的结果是稳定的。</p></blockquote><p>——-以上摘自《单元测试的艺术》–Roy Osherove</p><hr><p><a name="DPjgN"></a></p><h3 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h3><p><a name="U2lir"></a></p><h4 id="1-被测试系统"><a href="#1-被测试系统" class="headerlink" title="1.被测试系统"></a>1.被测试系统</h4><p>SUT 代表System Under Test。在测试中，被测试的对象称为SUT。</p><hr><p><a name="cPFKF"></a></p><h4 id="2-工作单元"><a href="#2-工作单元" class="headerlink" title="2.工作单元"></a>2.工作单元</h4><p>从调用系统的一个公共方法到产生一个测试可见的最终结果，其间这个系统发生的行为总称为一个工作单元(unit of work)。<br />最终结果结果可以是以下任何一种形式：</p><ul><li>被调用的公共方法返回一个值。</li><li>在方法调用前后，系统的状态或者行为有可见的变化，这种变化无需查询私有状态即可判断。</li><li>调用了一个不受测试控制的第三方系统，这个第三方系统不返回任何值，或者返回值都被忽略了。</li></ul><p>这里的Unit of work与DDD中的UnitOfWork概念不一样，UOW是一种数据访问模式， 是用来管理仓储，处理事务的，仓储用来解耦的（领域层与基础设施层）。</p><hr><p><a name="D9T8C"></a></p><h4 id="3-自动化测试的大致分类"><a href="#3-自动化测试的大致分类" class="headerlink" title="3.自动化测试的大致分类"></a>3.自动化测试的大致分类</h4><p><strong><img src="https://cdn.nlark.com/yuque/0/2021/png/10356904/1609910996992-d5843d43-ec04-45a6-9664-ffbc0ad38305.png#align=left&display=inline&height=600&margin=%5Bobject%20Object%5D&name=%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB.png&originHeight=600&originWidth=1156&size=17369&status=done&style=none&width=1156" alt="单元测试分类.png"></strong><br />纵轴表示测试的深度，也就是说测试的细致程度。<br />横轴则表示测试的覆盖程度。</p><ul><li>Unit Test 单元测试， 它可以测试一个类，或者一个类的某个功能，它具有很好的深度，但是对整个应用来说它不具备很好的覆盖面。</li><li>Integration Test 集成测试，它没有单元测试那么细致，但是具有相对较好的测试覆盖面。例如它可以测试功能的组合，以及像数据库或文件系统这样的外部资源等。</li><li>Subcutaneous Test 皮下测试，也有的叫接口测试，这种测试作用于UI层的下面一层，这也意味着它对整个应用来说有很好的覆盖率，但是深度欠佳。以一个MVC结构的应用来说，它就是针对刚好在Controller那一层的测试，对于Web service或者WCF来说，它就是对终结点 那层的测试。</li><li>UI测试，它的测试覆盖面很广，直接从UI层面进行测试，但是深度欠佳。</li></ul><p>从速度来看 单元是最快的，而UI测试是最慢的。<br />从脆弱性来看 UI测试是最差的，程序修改后极有可能需要修改测试代码，而单元测试是最好的。</p><hr><p><a name="qum1U"></a></p><h4 id="4-集成测试"><a href="#4-集成测试" class="headerlink" title="4.集成测试"></a>4.集成测试</h4><blockquote><p>集成测试是对一个工作单元进行的测试，则个测试对被测试的工作单元没有完全的控制，并使用该单元的一个或者多个真实依赖物，例如时间，网络，数据库，现成或者随机数产生器。</p></blockquote><p>集成测试与单元测试最大的区别就是，集成测试会使用真实依赖物，而单元测试则把被测试单元和其依赖物隔离开，以保证单元测试结果高度稳定，还可以轻易控制和模拟被测试单元行为的任何方面。<br /> 实际工作中，集成测试和单元测试很容易混在一起。<br />我们在编写测试代码的时候应该尽量将这两种测试区分开。<br />一般的测试框架也同时支持单元测试和集成测试。</p><hr><p><a name="fEKAy"></a></p><h4 id="5-测试驱动开发"><a href="#5-测试驱动开发" class="headerlink" title="5.测试驱动开发"></a>5.测试驱动开发</h4><p>测试驱动开发(Test-Driven Development,TDD)的具体含义有很多不同的观点，这里引用一个观点。</p><blockquote><p>TDD是一个软件开发过程，这个过程依赖于重复性的小开发周期：需求被转化为具体的测试用例，然后改进程序以便通过测试。</p></blockquote><p>TDD和传统开发方式不同，我们首先会编写一个会失败的测试，然后创建产品代码，并确保这个测试通过，接下来就是重构代码或者创建另一个会失败的测试。<br />看下面两张图：<br />** 传统的开发流程**<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/10356904/1609912776362-677a6a77-5611-4474-a45f-0e91a1119f5f.png#align=left&display=inline&height=407&margin=%5Bobject%20Object%5D&name=%E4%BC%A0%E7%BB%9F%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B.png&originHeight=544&originWidth=730&size=98877&status=done&style=none&width=546" alt="传统测试流程.png"><br /><strong>TDD开发流程</strong><br /><img src="https://cdn.nlark.com/yuque/0/2021/png/10356904/1609912830411-7e0c11f7-32f2-4f74-be42-6126017d6de8.png#align=left&display=inline&height=586&margin=%5Bobject%20Object%5D&name=TDD%E6%B5%81%E7%A8%8B.png&originHeight=758&originWidth=867&size=220564&status=done&style=none&width=670" alt="TDD流程.png"><br />在TDD里有两条规则：<br />只在有未通过的自动化测试的情况下，你才会去写新的代码<br />消灭重复<br /><br><br />这两条规则在技术上的含义是：<br />你必须进行良好的设计，运行的代码可在决策之间提供反馈<br />开发人员得写自己的测试<br />开发环境可以针对微小的变化需要提供快速的响应<br />您的设计必须由众多高内聚、低耦合的组件组成，这样测试会更简单。<br /><br><br />这两条规则也意味着编程的三个任务：<br />Red - 先写一个不能工作/通过的小测试，甚至根本无法编译<br />Green - 快速让这个测试通过，无论代码有多烂<br />Refactor - 重构，消除上个步骤中的代码重复。<br />Red，Green，Refactor，这就是TDD的三字真言。<br /><br><br /> 我们现在主要讲如何编写单元测试，而不是讲测试驱动开发。其他关于TDD的细节可以上网查询。</p><hr><p><a name="kFwZK"></a></p><h2 id="为什么要做单元测试"><a href="#为什么要做单元测试" class="headerlink" title="为什么要做单元测试"></a>为什么要做单元测试</h2><ul><li>可以频繁的进行测试</li><li>可以在任何时间进行测试，也可以按计划定时进行，例如：可以在半夜进行自动测试。</li><li>肯定比人工测试要快。</li><li>可以更快速的发现错误。</li><li>基本上是非常可靠的。</li><li>测试代码与生产代码紧密结合。</li><li>使得开发团队更具有幸福感！</li></ul><hr><p><a name="N2FPM"></a></p><h2 id="什么是优秀的单元测试"><a href="#什么是优秀的单元测试" class="headerlink" title="什么是优秀的单元测试"></a>什么是优秀的单元测试</h2><p>一个优秀的单元测试应当具有以下特征：</p><ul><li>它应该是自动化的，可重复执行的；</li><li>它应该很容易实现；</li><li>它应该第二天还有意义；</li><li>它任何人都应该能一键运行它；</li><li>它应该运行速度很快；</li><li>它的结果应该是稳定的（如果运行期间没有进行修改的话，多次运行一个测试应该总是返回同样的结果）；</li><li>它应该能完全控制被测试的单元；</li><li>它应该是完全隔离的（独立于其他测试的运行）</li></ul><hr><p><a name="cpOjq"></a></p><h2 id="单元测试框架"><a href="#单元测试框架" class="headerlink" title="单元测试框架"></a>单元测试框架</h2><p>单元测试框架是帮助开发人员进行单元测试的代码库或者模块。单元测试框架还可以作为自动编译过程的一个步骤运行测试。<br /></p><p><a name="ZTnCW"></a></p><h3 id="单元测试框架的功能："><a href="#单元测试框架的功能：" class="headerlink" title="单元测试框架的功能："></a>单元测试框架的功能：</h3><ul><li>运行 Test Case：这包括直接运行测试用例，或是以数据驱动的方式来运行</li><li>断言判断：用来判断测试结果是否合理的系统支持</li><li>不同级别的Fixture（夹具，这个单词这么翻译过来总觉的怪怪的~~）：即可以在Case开始和结束的时候做一些初始化的操作，以及支持自动化测试的理念</li><li>输出日志：可以在不同的载体上输出Case的运行日志</li></ul><p><a name="lR0Xr"></a></p><h3 id="三大主流测试框架："><a href="#三大主流测试框架：" class="headerlink" title="三大主流测试框架："></a>三大主流测试框架：</h3><p><a name="FE0NH"></a></p><h4 id="MSTest"><a href="#MSTest" class="headerlink" title="MSTest"></a><a href="https://docs.microsoft.com/zh-cn/visualstudio/test/using-microsoft-visualstudio-testtools-unittesting-members-in-unit-tests?view=vs-2019">MSTest</a></h4><p>MS Test框架是Visual Studio自带的测试框架，可以通过新建一个Unit Test Project工程，也可以建一个Class Libary，然后添加对Microsoft.VisualStudio.QualityTools.UnitTestFramework.dll的引用。<br />然后就是创建测试用例，进行测试即可。<br><a name="HAlom"></a></p><h4 id="NUnit"><a href="#NUnit" class="headerlink" title="NUnit"></a><a href="https://nunit.org/">NUnit</a></h4><p>NUnit Test框架是一个xUnit家族种的第4个主打产品，完全由C#语言来编写，支持所有的.Net语言。<br />使用NUnit框架，我们需要下载<a href="http://www.nunit.org/index.php?p=download">安装包</a>，安装后使用独立客户端进行使用。使用方法与MS Test类似，<br />新建一个Class Libary，然后添加对nunit.framework.dll的引用，最后创建测试用例，在客户端中进行测试。<br><a name="9SpwL"></a></p><h4 id="XUnit-Net"><a href="#XUnit-Net" class="headerlink" title="XUnit.Net"></a><a href="https://github.com/xunit/xunit">XUnit.Net</a></h4><p>xUnit.Net的由来：NUnit的创造者Jim Newkirk公布了一个新的单元测试框架，叫做xUnit.net。这是一个以NUnit的接班人自许的新框架，作者打算消除NUnit的错误和缺点，并在框架中加入一些最佳实践和扩展能力。xUnit.Net是开源的GitHub地址：<a href="https://github.com/xunit/xunit">https://github.com/xunit/xunit</a>。<br />下一篇，我们将以XUnit.Net作为这一系列技术分享的主要测试框架。<br><a name="J6y4A"></a></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <categories>
      
      <category>学习计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单元测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>batchprint</title>
    <link href="/2020/10/26/batchprint/"/>
    <url>/2020/10/26/batchprint/</url>
    
    <content type="html"><![CDATA[<h1 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h1><p>为了解决目前EES中批量打印对html页面的支持问题，以及提高速度和降低依赖，设计了这个项目。</p><h1 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术</h1><h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a><a href="https://nodejs.org/zh-cn/">Node.js</a></h2><p><a href="https://nodejs.org/zh-cn/">Node.js</a>是一个Javascript运行环境(runtime)，发布于2009年5月，由Ryan Dahl开发，实质是对Chrome V8引擎进行了封装。<br>Node.js对一些特殊用例进行优化，提供替代的API，使得V8在非浏览器环境下运行得更好。V8引擎执行Javascript的速度非常快，性能非常好。<br>Node.js是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。<br>Node.js 使用事件驱动，非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。</p><h2 id="Restify"><a href="#Restify" class="headerlink" title="Restify"></a><a href="http://restify.com/">Restify</a></h2><p>Restify 是一个 Node.JS 模块，可以让你创建正确的 REST web services。它借鉴了很多 express 的设计，因为它是 node.js web 应用事实上的标准 API。</p><h2 id="headless-chrome"><a href="#headless-chrome" class="headerlink" title="headless-chrome"></a><a href="https://developers.google.com/web/updates/2017/04/headless-chrome">headless-chrome</a></h2><p>Headless Chrome 是 Chrome 浏览器的无界面形态，可以在不打开浏览器的前提下，使用所有 Chrome 支持的特性运行你的程序。相比于现代浏览器，Headless Chrome 更加方便测试 web 应用，获得网站的截图，做爬虫抓取信息等。相比于出道较早的 PhantomJS，SlimerJS 等，Headless Chrome 则更加贴近浏览器环境。</p><h2 id="puppeteer"><a href="#puppeteer" class="headerlink" title="puppeteer"></a><a href="https://github.com/GoogleChrome/puppeteer">puppeteer</a></h2><p>Puppeteer 是一个控制 headless Chrome 的 Node.js API 。它是一个 Node.js 库，通过 DevTools 协议提供了一个高级的 API 来控制 headless Chrome。它还可以配置为使用完整的（非 headless）Chrome。<br>在浏览器中手动完成的大多数事情都可以通过使用 Puppeteer 完成，下面是一些入门的例子：</p><ul><li>生成屏幕截图和 PDF 页面</li><li>检索 SPA 并生成预渲染内容（即“SSR”）</li><li>从网站上爬取内容</li><li>自动提交表单，UI测试，键盘输入等</li><li>创建一个最新的自动测试环境。使用最新的 JavaScript 和浏览器功能，在最新版本的 Chrome 中直接运行测试</li><li>捕获网站的时间线跟踪，以帮助诊断性能问题</li></ul><h1 id="项目主要功能"><a href="#项目主要功能" class="headerlink" title="项目主要功能"></a>项目主要功能</h1><ul><li>提供一个Web API,接收用户的批量打印请求。请求中至少携带一个页面的URL地址。</li><li>处理批量打印请求，使用Chrome 的 headless方式访问请求中指定的页面。</li><li>使用Chrome的API将网页另存为PDF文档。</li><li>提供PDF文档的URL供下载或者浏览。</li><li>需要考虑批量打印的PDF整合问题。</li></ul><h1 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h1><p>以Windows开发环境为例。</p><h2 id="1-安装Node-js"><a href="#1-安装Node-js" class="headerlink" title="1. 安装Node.js"></a>1. 安装Node.js</h2><p>到<a href="https://nodejs.org/zh-cn/">Node.js</a>官网下载最新版的node.js,版本要求&gt;8.0 。</p><h2 id="2-创建项目"><a href="#2-创建项目" class="headerlink" title="2. 创建项目"></a>2. 创建项目</h2><p>在你认为合适的地方创建一个STAr-BatchPrint(可自定义)文件夹，使用CMD打开文件夹，执行如下命令:</p><pre><code>npm init</code></pre><p>npm 会引导你创建package.json的文件。关于NPM其他相关命令请参考<a href="https://docs.npmjs.com/cli/init">NPM命令说明</a></p><h2 id="3-安装扩展包"><a href="#3-安装扩展包" class="headerlink" title="3. 安装扩展包"></a>3. 安装扩展包</h2><p>在命令行 执行</p><pre><code>npm install restify puppeteer --save</code></pre><p>安装 Restify和Pupperteer两个包，记得加上–save以便更新至packag.json中。<br>pupeteer会下载一个特别的Chrome浏览器到你的项目中，大概120MB，请耐心等待…</p><p>至此，项目开发环境就全部搭建完成。</p><h1 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h1><h2 id="创建index-js并引入扩展包"><a href="#创建index-js并引入扩展包" class="headerlink" title="创建index.js并引入扩展包"></a>创建index.js并引入扩展包</h2><p>首先我们得创建一个index.js，此文件是项目的启动文件。</p><pre><code><pre><code class="hljs javascript"> <span class="hljs-comment">// 引入puppeteer和restify</span><span class="hljs-keyword">const</span> puppeteer = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;puppeteer&#x27;</span>);<span class="hljs-keyword">const</span> restify = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;restify&#x27;</span>);</code></pre></code></pre><h2 id="创建Restify-API-Server"><a href="#创建Restify-API-Server" class="headerlink" title="创建Restify API Server"></a>创建Restify API Server</h2><p>使用Restify提供的方法创建一个Server，并指定IP和端口。</p><pre><code><pre><code class="hljs javascript"><span class="hljs-comment">//指定Server的IP地址和端口</span><span class="hljs-keyword">const</span> ip_addr = <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>; <span class="hljs-keyword">const</span> port = <span class="hljs-string">&#x27;8080&#x27;</span>;<span class="hljs-comment">//启动Server</span><span class="hljs-keyword">var</span> server = restify.createServer(&#123;name: <span class="hljs-string">&#x27;Batch-Print-Server&#x27;</span>&#125;);<span class="hljs-comment">//启动服务端监听</span>server.listen(port, ip_addr, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;%s listening at %s &#x27;</span>, server.name, server.url);&#125;);</code></pre></code></pre><h2 id="配置API的Route"><a href="#配置API的Route" class="headerlink" title="配置API的Route"></a>配置API的Route</h2><p>我们使用/print 来处理关于打印的请求。<br>其中postNewPrintJob为该请求的Post回调函数。下面我们来实现它。</p><pre><code><pre><code class="hljs javascript"><span class="hljs-comment">//启用restify的插件</span>server.use(restify.plugins.queryParser());server.use(restify.plugins.bodyParser(&#123; <span class="hljs-attr">requestBodyOnGet</span>: <span class="hljs-literal">true</span> &#125;));<span class="hljs-comment">//指定根路由返回内容</span>server.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) </span>&#123;res.send(<span class="hljs-string">&#x27;Hello BatchPrint!&#x27;</span>);<span class="hljs-keyword">return</span> next();&#125;);<span class="hljs-comment">// testing the service  </span>server.get(<span class="hljs-string">&#x27;/test&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) </span>&#123;      res.send(<span class="hljs-string">&quot;testing...&quot;</span>);      next();  &#125;);<span class="hljs-comment">//指定Route</span>PATH = <span class="hljs-string">&#x27;/print&#x27;</span>;<span class="hljs-comment">//指定相应Route的方法</span>server.post(&#123; <span class="hljs-attr">path</span>: PATH, <span class="hljs-attr">version</span>: <span class="hljs-string">&#x27;0.0.1&#x27;</span> &#125;, postNewPrintJob);</code></pre></code></pre><h2 id="实现postNewPrintJob"><a href="#实现postNewPrintJob" class="headerlink" title="实现postNewPrintJob"></a>实现postNewPrintJob</h2><p>该回调函数主要处理请求的数据，以及完成生成PDF的操作。</p><pre><code><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">postNewPrintJob</span>(<span class="hljs-params">req, res, next</span>) </span>&#123;<span class="hljs-keyword">var</span> job = &#123;&#125;;<span class="hljs-comment">//    job.title = req.params.title;</span><span class="hljs-comment">//    job.description = req.params.description;</span>job.location = req.params.location;job.filename = req.params.filename;job.postedOn = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toLocaleString();<span class="hljs-built_in">console</span>.log(job);<span class="hljs-comment">//设置跨域响应</span>res.setHeader(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>);(<span class="hljs-keyword">async</span> () =&gt; &#123;    <span class="hljs-comment">//启动Chrome</span>    <span class="hljs-keyword">const</span> browser = <span class="hljs-keyword">await</span> puppeteer.launch();    <span class="hljs-comment">//新建Page</span>    <span class="hljs-keyword">const</span> page = <span class="hljs-keyword">await</span> browser.newPage();    <span class="hljs-comment">//打开页面 load方式指页面所有事务执行完毕</span>    <span class="hljs-keyword">await</span> page.goto(job.location, &#123; <span class="hljs-attr">waitUntil</span>: <span class="hljs-string">&#x27;load&#x27;</span> &#125;);    <span class="hljs-comment">//指定响应Media为Print</span>    <span class="hljs-keyword">await</span> page.emulateMedia(<span class="hljs-string">&#x27;print&#x27;</span>);    <span class="hljs-comment">//生成PDF文件，format设为A4,margin为默认页边距。</span>    <span class="hljs-keyword">const</span> pdffile = <span class="hljs-keyword">await</span> page.pdf(&#123;    path: pdffiledirectory+<span class="hljs-string">&#x27;/&#x27;</span>+job.filename,    format: <span class="hljs-string">&#x27;A4&#x27;</span>,    margin: &#123;        top: <span class="hljs-string">&#x27;10mm&#x27;</span>,        bottom: <span class="hljs-string">&#x27;10mm&#x27;</span>,        left: <span class="hljs-string">&#x27;10mm&#x27;</span>,        right: <span class="hljs-string">&#x27;10mm&#x27;</span>    &#125;    &#125;);    <span class="hljs-comment">//关闭浏览器。</span>    browser.close();    <span class="hljs-keyword">if</span> (pdffile) &#123;    <span class="hljs-comment">//返回结果。</span>    res.send(<span class="hljs-number">200</span>, pdffile);    <span class="hljs-keyword">return</span> next();    &#125;    <span class="hljs-keyword">return</span> next(err);&#125;)();</code></pre></code></pre><p>上面的方法可以看到其中使用了Pupperteer对Chrome进行操作。具体API可以查询<a href="https://github.com/GoogleChrome/puppeteer">Pupperteer</a>的GitHub.</p><p>具体代码请查看<a href="https://github.com/zhangwei8387/STAr-BatchPrint/blob/master/index.js">index.js</a></p><h2 id="启动Server"><a href="#启动Server" class="headerlink" title="启动Server"></a>启动Server</h2><p>在CMD命令行中执行node index.js</p><pre><code>PS D:\GitCode\STAr-BatchPrint&gt; node index.js</code></pre><p>会返回如下信息:</p><pre><code>Batch-Print-Server listening at http://127.0.0.1:8080</code></pre><p>表示服务已经开启。</p><h2 id="测试服务"><a href="#测试服务" class="headerlink" title="测试服务"></a>测试服务</h2><p>在浏览器中打开<a href="http://127.0.0.1:8080/%E3%80%82%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E5%A6%82%E4%B8%8B%E4%BF%A1%E6%81%AF">http://127.0.0.1:8080/。我们可以看到如下信息</a>.</p><pre><code>&quot;Hello BatchPrint!&quot;</code></pre><p>访问下级路由，<a href="http://127.0.0.1:8080/test%E3%80%82%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E5%A6%82%E4%B8%8B%E4%BF%A1%E6%81%AF">http://127.0.0.1:8080/test。我们可以看到如下信息</a>.</p><pre><code>&quot;testing...&quot;</code></pre><p>但是我们如果访问 <a href="http://127.0.0.1:8080/print">http://127.0.0.1:8080/print</a>, 会得到一个错误信息。</p><pre><code>&#123;&quot;code&quot;:&quot;MethodNotAllowed&quot;,&quot;message&quot;:&quot;GET is not allowed&quot;&#125;</code></pre><p>说明这个路由并没有指定Get方法。因为我们使用Post来向服务器推送数据。</p><p>推荐使用<a href="https://www.getpostman.com/">PostMan</a>API测试工具来向Server Post我们模拟的数据。</p><p>点击Send后，在我们Server的目录中会生成一个PDF文档。打开后就可以看到指定网页的内容。</p>]]></content>
    
    
    <categories>
      
      <category>开发技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>言传身教</title>
    <link href="/2020/10/21/%E8%A8%80%E4%BC%A0%E8%BA%AB%E6%95%99/"/>
    <url>/2020/10/21/%E8%A8%80%E4%BC%A0%E8%BA%AB%E6%95%99/</url>
    
    <content type="html"><![CDATA[<p>言传身教，又以后者更重要.</p><p>言传为虚，身教为实，</p><p>因为孩子未必听得懂大人的那些个道理，但是对世界最好奇，要孩子耳朵里听得进、装得下道理，很难.<br>孩子眼睛里看见更多，更容易记住这个世道的大致模样，比较浅显，黑白分明，稚嫩却尤为可贵.<br>这么潜移默化下去，自己都浑然不觉，点点滴滴，年年月月，心目中的世界就定型了，再难更改。</p><p>所以好些个看似长大成人后，有违旁人印象的一些莫名其妙的举措，其实早就有迹可循。<br>在一个打磨器型的关键时刻，父母的言行，至关重要.<br>一句做错了事却骂不到点子上的训斥.<br>或是做错了，干脆就觉得自家孩子年纪太小，选择视而不见，最后可不就是害人害己害子女嘛。</p><p>所以要赏罚分明，父母要学会给子女立规矩。<br>仁义，理之本也。刑罚，理之末也。</p>]]></content>
    
    
    <categories>
      
      <category>文摘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑来</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>未相逢于最好的年纪，却给了对方最丰富的自己</title>
    <link href="/2020/10/21/%E6%80%BB%E6%9C%89%E4%B8%80%E5%A4%A9%E8%A6%81%E8%B7%9F%E6%89%80%E6%9C%89%E7%9A%84%E8%AE%B0%E5%BF%86%E7%9B%B8%E5%AE%89%E6%97%A0%E4%BA%8B%E6%8F%A1%E6%89%8B%E8%A8%80%E5%92%8C/"/>
    <url>/2020/10/21/%E6%80%BB%E6%9C%89%E4%B8%80%E5%A4%A9%E8%A6%81%E8%B7%9F%E6%89%80%E6%9C%89%E7%9A%84%E8%AE%B0%E5%BF%86%E7%9B%B8%E5%AE%89%E6%97%A0%E4%BA%8B%E6%8F%A1%E6%89%8B%E8%A8%80%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p>我时常想起，曾在我生命中出现的姑娘们。她们无论在当时还是记忆里，都美好得一塌糊涂，优秀得让人目眩神迷。现如今，她们一定更漂亮、更从容、更丰富了，一定遇到了更多好玩的人，演绎了更多精彩的故事。</p><p>一个曾短暂出现在我生活里的女孩子，订婚了。我的兄弟，爱一个姑娘两年半，最后收获了她跟他人订婚的“喜讯”。我常跟他说，那个人永远活在时间里了，你把她拉不出来，自己也回不去，就这样吧，让她安静的留在那里吧。<br>她不会发福不会老去不会穿着职业套装高跟鞋不会带着家长里短柴油米醋的气息，她永远年轻永远漂亮穿着鲜艳长裙站在回忆里，对着你笑靥如花。</p><p><strong>这样难道不好吗？</strong></p><p>你总有一天要跟所有的记忆相安无事握手言和，那里面有她也有你，有她的青春也有你的年华。让它们留在那里吧。生活里每天都有相聚别离，号啕或欢欣。<br>如果最初相识的姑娘注定无法走到最后，你会依然选择相遇在年少？还是在看遍春花夏月秋风冬雪后遇到她携手走进余下的旅途？这似乎是个不值得一提的问题，几乎所有人都喜欢“地老天荒”这样的词汇吧。</p><p>但真的有那么简单吗？问题的关键在于，你想开头还是收尾？你们在成熟稳重、理智从容、笑不露齿、工作稳定、职业套装高跟鞋、西装革履的28岁30岁相遇，气味相投性情相依相见恨晚唯怨月老一度瞎了眼，一段佳话就此开始，郎才女貌珠联璧合天造地设等祝福潮水一般涌来。像是个完美的故事。</p><p>她穿泛着光泽的高跟鞋、考究的套裙，妆容一丝不乱，带到你的朋友同事面前措辞得体，无可挑剔。她不会大喊大叫跟你无理取闹，不会要吃某家的小笼包让你穿越三条街道，不会很轻易的跟你赌气怀疑你是否跟其他女孩子有一腿。她包容体贴贤惠孝顺，入得厨房出得厅堂。</p><p>可是随着日复一日的平庸到来，某个回望的瞬间，内心是否会有隐隐的遗憾？<br>你是否想有一台时光机，回到她20岁22岁的年纪，在食堂、在图书馆、在主干道上，走上前去或礼貌或猥琐或忐忑的说一声：你好。那时候的她，穿着鲜艳的长裙素面朝天，穿着匡威白色帆布鞋，顶着刚洗完的湿漉漉头发冲去食堂打饭，一路上甩落无数男生的惊叹。</p><p>她漂亮、骄傲、聪明，会为了舍友的一句话而耿耿于怀，会为言情剧哭得稀里哗啦，会看到玩具店里的可爱公仔走不动路，会期待某个特别的节日收到男生们的玫瑰花。她没那么得体，还没学会滴水不漏笑不露齿，带到朋友面前会捂着嘴一个劲儿的傻笑。她穿匡威帆布鞋，也喜欢淘宝上淘来的便宜凉拖，她不太喜欢化妆，穿着T恤短裤就往宿舍楼下冲，在路边那家麻辣烫一边流汗一边大呼好吃，她会撒娇会胡搅蛮缠不讲理会为脑子里突然蹦出的疯狂念头兴奋不已……</p><p>那时候的你呢。没什么钱，脚上穿着攒了很久生活费买来的新球鞋，骑着拉风的山地车飞速驶过人群，在大排档跟一群狐朋狗友扯着政治足球和姑娘，面对递过来的啤酒瓶毫不犹豫一仰而尽，你那么年轻、那么张扬，脑子里满是自命不凡的想象，大声喊世界是我们的。你的发型土土的没有那么多发胶，还没有自己的第一套西装，你还没学会克制忍耐学会礼貌微笑，不高兴了随口就来一句：去他娘的。她路过操场，看到你打球的样子。汗水顺发梢滑过你红红彤彤的脸，你大声叫喊积极奔跑，仿佛身上有使不完的力气。</p><p>你们相遇。没那么理智包容，也很难总是做到相互理解，她没那么精致的漂亮，你也离成熟睿智差得很远，一个愣头小子，一个天真的丫头，就那么说着天长地久生死相依的誓言，你们以为世界会按照自己想象的编排，不懂得生活中永远不变的就是一直在变。你们会吵架、会分手、会伤害、会分头走路、会把彼此留在回忆里不断折磨，但是亲爱的，那是你们最好的年纪。</p><p>《艋舺》里说，“风往哪边吹，草就往哪边倒。年轻的时候我也以为自己是风，等到遍体鳞伤以后，才知道，原来我们都是草。”我们未必如草随风倒，却也只能这样，模模糊糊往前走。</p><p><strong>时间什么都安排好了。</strong></p><p>年轻时，总想看遍世间的风景，时不时涌出冒险的冲动，想拉着心爱的姑娘私奔，即刻就流浪到海涯天角。现在才明白，你什么风景都看不透，很可能也没有细水长流。你只能在一季季的春花夏月秋雨冬雪中，丈量自己生命的边界。有可能，姑娘都不会来，你就一个人走路，或缓或急，或愉悦或悲伤。</p><p>我时常也会烂俗的想，未来的姑娘呦，你到底什么样。你丰满还是消瘦活泼还是文静？你留俏皮的短发还是如瀑的长丝？你是否也喜欢那些瑰丽奇妙的文字，沉溺于光怪陆离的影像故事？你是否也扛过了狼血和庸俗成功学疯狂的侵蚀，依然带着对生活令人发指的热爱，坚持做一个有趣的人？</p><p>不管在28还是35岁相遇，拍落满身的风尘后，我们唯一能庆幸的，是彼此一定有很多好玩的故事、路途的见闻讲给对方听，那是一个个动人的传奇。</p><p>未相逢于最好的年纪，却给了对方最丰富的自己。</p><p>我不知道你会不会来，但仍大声唱着歌，走向你。</p>]]></content>
    
    
    <categories>
      
      <category>文摘</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第一篇个人博客</title>
    <link href="/2020/10/20/hello-world/"/>
    <url>/2020/10/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p>这是我的第一篇个人博客，主要用于博客初始化搭建和样式调整</p><h1 id="为什么要写博客"><a href="#为什么要写博客" class="headerlink" title="为什么要写博客"></a>为什么要写博客</h1><h2 id="写作的意义"><a href="#写作的意义" class="headerlink" title="写作的意义"></a>写作的意义</h2><p>聪明的人类发明了语言创造了文字，而能将这一切传递下来的便是写作。写作对于自己来说，是思维的凝聚，是人格的升华。写作能让自己在百忙之中找到忙碌的意义，也能锻炼自己的表达能力，对于生活中的辩论与演讲都有很大的帮助。同时如果去写技术类文章的话，也有助于理清解决思路和提升技术实力，最终还能帮到别人，降低社会交流成本，提高笔者与读者的双向影响力。</p><p>借用现在的我自己来说，我在大学中同时是两个学生实验室的主力成员，还要顾及编程社区的推动和发展，更不能落下课内知识。这时抽时间去写作去用文字总结自己变让一切有了意义。同时因自己是程序员的原因，技术类文章也锻炼了自己的思维方式，提升了自己的技术软硬实力，和读者互动，了解了更多的故事。</p><h2 id="用博客落实写作"><a href="#用博客落实写作" class="headerlink" title="用博客落实写作"></a>用博客落实写作</h2><p>日记通常是给自己看的，曝光度有限，而在网络上发布的博客更能吸引到志同道合的人。用博客落实写作的一个最重要的原因便是自己的文章能够得到广大读者的反馈，还不会像论文一样严肃有力。最终博客能展现的除了罗列信息之外，还能加入自己的心路历程分享出去。也因此用博客落实写作便可以是笔者前期写作的源动力之一。</p><h2 id="用博客升华自己"><a href="#用博客升华自己" class="headerlink" title="用博客升华自己"></a>用博客升华自己</h2><p>通过多读书多提问而产出博客这整个过程，都能够抽离出解决问题、产出成功的方法论。通过写博客升华后的自己，完全可以将这种模式再加上具体情况去落实如何写 PPT、如何写文档、如何表达自己、如何辩论、如何演讲等等。。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
