<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>第一篇个人博客</title>
    <link href="/2020/10/26/hello-world/"/>
    <url>/2020/10/26/hello-world/</url>
    
    <content type="html"><![CDATA[<p>这是我的第一篇个人博客，主要用于博客初始化搭建和样式调整</p><h1 id="为什么要写博客"><a href="#为什么要写博客" class="headerlink" title="为什么要写博客"></a>为什么要写博客</h1><h2 id="写作的意义"><a href="#写作的意义" class="headerlink" title="写作的意义"></a>写作的意义</h2><p>聪明的人类发明了语言创造了文字，而能将这一切传递下来的便是写作。写作对于自己来说，是思维的凝聚，是人格的升华。写作能让自己在百忙之中找到忙碌的意义，也能锻炼自己的表达能力，对于生活中的辩论与演讲都有很大的帮助。同时如果去写技术类文章的话，也有助于理清解决思路和提升技术实力，最终还能帮到别人，降低社会交流成本，提高笔者与读者的双向影响力。</p><p>借用现在的我自己来说，我在大学中同时是两个学生实验室的主力成员，还要顾及编程社区的推动和发展，更不能落下课内知识。这时抽时间去写作去用文字总结自己变让一切有了意义。同时因自己是程序员的原因，技术类文章也锻炼了自己的思维方式，提升了自己的技术软硬实力，和读者互动，了解了更多的故事。</p><h2 id="用博客落实写作"><a href="#用博客落实写作" class="headerlink" title="用博客落实写作"></a>用博客落实写作</h2><p>日记通常是给自己看的，曝光度有限，而在网络上发布的博客更能吸引到志同道合的人。用博客落实写作的一个最重要的原因便是自己的文章能够得到广大读者的反馈，还不会像论文一样严肃有力。最终博客能展现的除了罗列信息之外，还能加入自己的心路历程分享出去。也因此用博客落实写作便可以是笔者前期写作的源动力之一。</p><h2 id="用博客升华自己"><a href="#用博客升华自己" class="headerlink" title="用博客升华自己"></a>用博客升华自己</h2><p>通过多读书多提问而产出博客这整个过程，都能够抽离出解决问题、产出成功的方法论。通过写博客升华后的自己，完全可以将这种模式再加上具体情况去落实如何写 PPT、如何写文档、如何表达自己、如何辩论、如何演讲等等。。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>batchprint</title>
    <link href="/2020/10/26/batchprint/"/>
    <url>/2020/10/26/batchprint/</url>
    
    <content type="html"><![CDATA[<h1 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h1><p>为了解决目前EES中批量打印对html页面的支持问题，以及提高速度和降低依赖，设计了这个项目。</p><h1 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术</h1><h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a><a href="https://nodejs.org/zh-cn/">Node.js</a></h2><p><a href="https://nodejs.org/zh-cn/">Node.js</a>是一个Javascript运行环境(runtime)，发布于2009年5月，由Ryan Dahl开发，实质是对Chrome V8引擎进行了封装。<br>Node.js对一些特殊用例进行优化，提供替代的API，使得V8在非浏览器环境下运行得更好。V8引擎执行Javascript的速度非常快，性能非常好。<br>Node.js是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。<br>Node.js 使用事件驱动，非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。</p><h2 id="Restify"><a href="#Restify" class="headerlink" title="Restify"></a><a href="http://restify.com/">Restify</a></h2><p>Restify 是一个 Node.JS 模块，可以让你创建正确的 REST web services。它借鉴了很多 express 的设计，因为它是 node.js web 应用事实上的标准 API。</p><h2 id="headless-chrome"><a href="#headless-chrome" class="headerlink" title="headless-chrome"></a><a href="https://developers.google.com/web/updates/2017/04/headless-chrome">headless-chrome</a></h2><p>Headless Chrome 是 Chrome 浏览器的无界面形态，可以在不打开浏览器的前提下，使用所有 Chrome 支持的特性运行你的程序。相比于现代浏览器，Headless Chrome 更加方便测试 web 应用，获得网站的截图，做爬虫抓取信息等。相比于出道较早的 PhantomJS，SlimerJS 等，Headless Chrome 则更加贴近浏览器环境。</p><h2 id="puppeteer"><a href="#puppeteer" class="headerlink" title="puppeteer"></a><a href="https://github.com/GoogleChrome/puppeteer">puppeteer</a></h2><p>Puppeteer 是一个控制 headless Chrome 的 Node.js API 。它是一个 Node.js 库，通过 DevTools 协议提供了一个高级的 API 来控制 headless Chrome。它还可以配置为使用完整的（非 headless）Chrome。<br>在浏览器中手动完成的大多数事情都可以通过使用 Puppeteer 完成，下面是一些入门的例子：</p><ul><li>生成屏幕截图和 PDF 页面</li><li>检索 SPA 并生成预渲染内容（即“SSR”）</li><li>从网站上爬取内容</li><li>自动提交表单，UI测试，键盘输入等</li><li>创建一个最新的自动测试环境。使用最新的 JavaScript 和浏览器功能，在最新版本的 Chrome 中直接运行测试</li><li>捕获网站的时间线跟踪，以帮助诊断性能问题</li></ul><h1 id="项目主要功能"><a href="#项目主要功能" class="headerlink" title="项目主要功能"></a>项目主要功能</h1><ul><li>提供一个Web API,接收用户的批量打印请求。请求中至少携带一个页面的URL地址。</li><li>处理批量打印请求，使用Chrome 的 headless方式访问请求中指定的页面。</li><li>使用Chrome的API将网页另存为PDF文档。</li><li>提供PDF文档的URL供下载或者浏览。</li><li>需要考虑批量打印的PDF整合问题。</li></ul><h1 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h1><p>以Windows开发环境为例。</p><h2 id="1-安装Node-js"><a href="#1-安装Node-js" class="headerlink" title="1. 安装Node.js"></a>1. 安装Node.js</h2><p>到<a href="https://nodejs.org/zh-cn/">Node.js</a>官网下载最新版的node.js,版本要求&gt;8.0 。</p><h2 id="2-创建项目"><a href="#2-创建项目" class="headerlink" title="2. 创建项目"></a>2. 创建项目</h2><p>在你认为合适的地方创建一个STAr-BatchPrint(可自定义)文件夹，使用CMD打开文件夹，执行如下命令:</p><pre><code>npm init</code></pre><p>npm 会引导你创建package.json的文件。关于NPM其他相关命令请参考<a href="https://docs.npmjs.com/cli/init">NPM命令说明</a></p><h2 id="3-安装扩展包"><a href="#3-安装扩展包" class="headerlink" title="3. 安装扩展包"></a>3. 安装扩展包</h2><p>在命令行 执行</p><pre><code>npm install restify puppeteer --save</code></pre><p>安装 Restify和Pupperteer两个包，记得加上–save以便更新至packag.json中。<br>pupeteer会下载一个特别的Chrome浏览器到你的项目中，大概120MB，请耐心等待…</p><p>至此，项目开发环境就全部搭建完成。</p><h1 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h1><h2 id="创建index-js并引入扩展包"><a href="#创建index-js并引入扩展包" class="headerlink" title="创建index.js并引入扩展包"></a>创建index.js并引入扩展包</h2><p>首先我们得创建一个index.js，此文件是项目的启动文件。</p><pre><code><pre><code class="hljs javascript"> <span class="hljs-comment">// 引入puppeteer和restify</span><span class="hljs-keyword">const</span> puppeteer = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;puppeteer&#x27;</span>);<span class="hljs-keyword">const</span> restify = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;restify&#x27;</span>);</code></pre></code></pre><h2 id="创建Restify-API-Server"><a href="#创建Restify-API-Server" class="headerlink" title="创建Restify API Server"></a>创建Restify API Server</h2><p>使用Restify提供的方法创建一个Server，并指定IP和端口。</p><pre><code><pre><code class="hljs javascript"><span class="hljs-comment">//指定Server的IP地址和端口</span><span class="hljs-keyword">const</span> ip_addr = <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>; <span class="hljs-keyword">const</span> port = <span class="hljs-string">&#x27;8080&#x27;</span>;<span class="hljs-comment">//启动Server</span><span class="hljs-keyword">var</span> server = restify.createServer(&#123;name: <span class="hljs-string">&#x27;Batch-Print-Server&#x27;</span>&#125;);<span class="hljs-comment">//启动服务端监听</span>server.listen(port, ip_addr, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;%s listening at %s &#x27;</span>, server.name, server.url);&#125;);</code></pre></code></pre><h2 id="配置API的Route"><a href="#配置API的Route" class="headerlink" title="配置API的Route"></a>配置API的Route</h2><p>我们使用/print 来处理关于打印的请求。<br>其中postNewPrintJob为该请求的Post回调函数。下面我们来实现它。</p><pre><code><pre><code class="hljs javascript"><span class="hljs-comment">//启用restify的插件</span>server.use(restify.plugins.queryParser());server.use(restify.plugins.bodyParser(&#123; <span class="hljs-attr">requestBodyOnGet</span>: <span class="hljs-literal">true</span> &#125;));<span class="hljs-comment">//指定根路由返回内容</span>server.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) </span>&#123;res.send(<span class="hljs-string">&#x27;Hello BatchPrint!&#x27;</span>);<span class="hljs-keyword">return</span> next();&#125;);<span class="hljs-comment">// testing the service  </span>server.get(<span class="hljs-string">&#x27;/test&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) </span>&#123;      res.send(<span class="hljs-string">&quot;testing...&quot;</span>);      next();  &#125;);<span class="hljs-comment">//指定Route</span>PATH = <span class="hljs-string">&#x27;/print&#x27;</span>;<span class="hljs-comment">//指定相应Route的方法</span>server.post(&#123; <span class="hljs-attr">path</span>: PATH, <span class="hljs-attr">version</span>: <span class="hljs-string">&#x27;0.0.1&#x27;</span> &#125;, postNewPrintJob);</code></pre></code></pre><h2 id="实现postNewPrintJob"><a href="#实现postNewPrintJob" class="headerlink" title="实现postNewPrintJob"></a>实现postNewPrintJob</h2><p>该回调函数主要处理请求的数据，以及完成生成PDF的操作。</p><pre><code><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">postNewPrintJob</span>(<span class="hljs-params">req, res, next</span>) </span>&#123;<span class="hljs-keyword">var</span> job = &#123;&#125;;<span class="hljs-comment">//    job.title = req.params.title;</span><span class="hljs-comment">//    job.description = req.params.description;</span>job.location = req.params.location;job.filename = req.params.filename;job.postedOn = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toLocaleString();<span class="hljs-built_in">console</span>.log(job);<span class="hljs-comment">//设置跨域响应</span>res.setHeader(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>);(<span class="hljs-keyword">async</span> () =&gt; &#123;    <span class="hljs-comment">//启动Chrome</span>    <span class="hljs-keyword">const</span> browser = <span class="hljs-keyword">await</span> puppeteer.launch();    <span class="hljs-comment">//新建Page</span>    <span class="hljs-keyword">const</span> page = <span class="hljs-keyword">await</span> browser.newPage();    <span class="hljs-comment">//打开页面 load方式指页面所有事务执行完毕</span>    <span class="hljs-keyword">await</span> page.goto(job.location, &#123; <span class="hljs-attr">waitUntil</span>: <span class="hljs-string">&#x27;load&#x27;</span> &#125;);    <span class="hljs-comment">//指定响应Media为Print</span>    <span class="hljs-keyword">await</span> page.emulateMedia(<span class="hljs-string">&#x27;print&#x27;</span>);    <span class="hljs-comment">//生成PDF文件，format设为A4,margin为默认页边距。</span>    <span class="hljs-keyword">const</span> pdffile = <span class="hljs-keyword">await</span> page.pdf(&#123;    path: pdffiledirectory+<span class="hljs-string">&#x27;/&#x27;</span>+job.filename,    format: <span class="hljs-string">&#x27;A4&#x27;</span>,    margin: &#123;        top: <span class="hljs-string">&#x27;10mm&#x27;</span>,        bottom: <span class="hljs-string">&#x27;10mm&#x27;</span>,        left: <span class="hljs-string">&#x27;10mm&#x27;</span>,        right: <span class="hljs-string">&#x27;10mm&#x27;</span>    &#125;    &#125;);    <span class="hljs-comment">//关闭浏览器。</span>    browser.close();    <span class="hljs-keyword">if</span> (pdffile) &#123;    <span class="hljs-comment">//返回结果。</span>    res.send(<span class="hljs-number">200</span>, pdffile);    <span class="hljs-keyword">return</span> next();    &#125;    <span class="hljs-keyword">return</span> next(err);&#125;)();</code></pre></code></pre><p>上面的方法可以看到其中使用了Pupperteer对Chrome进行操作。具体API可以查询<a href="https://github.com/GoogleChrome/puppeteer">Pupperteer</a>的GitHub.</p><p>具体代码请查看<a href="https://github.com/zhangwei8387/STAr-BatchPrint/blob/master/index.js">index.js</a></p><h2 id="启动Server"><a href="#启动Server" class="headerlink" title="启动Server"></a>启动Server</h2><p>在CMD命令行中执行node index.js</p><pre><code>PS D:\GitCode\STAr-BatchPrint&gt; node index.js</code></pre><p>会返回如下信息:</p><pre><code>Batch-Print-Server listening at http://127.0.0.1:8080</code></pre><p>表示服务已经开启。</p><h2 id="测试服务"><a href="#测试服务" class="headerlink" title="测试服务"></a>测试服务</h2><p>在浏览器中打开<a href="http://127.0.0.1:8080/%E3%80%82%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E5%A6%82%E4%B8%8B%E4%BF%A1%E6%81%AF">http://127.0.0.1:8080/。我们可以看到如下信息</a>.</p><pre><code>&quot;Hello BatchPrint!&quot;</code></pre><p>访问下级路由，<a href="http://127.0.0.1:8080/test%E3%80%82%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E5%A6%82%E4%B8%8B%E4%BF%A1%E6%81%AF">http://127.0.0.1:8080/test。我们可以看到如下信息</a>.</p><pre><code>&quot;testing...&quot;</code></pre><p>但是我们如果访问 <a href="http://127.0.0.1:8080/print">http://127.0.0.1:8080/print</a>, 会得到一个错误信息。</p><pre><code>&#123;&quot;code&quot;:&quot;MethodNotAllowed&quot;,&quot;message&quot;:&quot;GET is not allowed&quot;&#125;</code></pre><p>说明这个路由并没有指定Get方法。因为我们使用Post来向服务器推送数据。</p><p>推荐使用<a href="https://www.getpostman.com/">PostMan</a>API测试工具来向Server Post我们模拟的数据。</p><p>点击Send后，在我们Server的目录中会生成一个PDF文档。打开后就可以看到指定网页的内容。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>言传身教</title>
    <link href="/2020/10/21/%E8%A8%80%E4%BC%A0%E8%BA%AB%E6%95%99/"/>
    <url>/2020/10/21/%E8%A8%80%E4%BC%A0%E8%BA%AB%E6%95%99/</url>
    
    <content type="html"><![CDATA[<p>言传身教，又以后者更重要，言传为虚，身教为实，因为孩子未必听得懂大人的那些个道理，但是对世界最好奇，要孩子耳朵里听得进、装得下道理，很难，孩子眼睛里看见更多，更容易记住这个世道的大致模样，比较浅显，黑白分明，稚嫩却尤为可贵，这么潜移默化下去，自己都浑然不觉，点点滴滴，年年月月，心目中的世界就定型了，再难更改。所以好些个看似长大成人后，有违旁人印象的一些莫名其妙的举措，其实早就有迹可循。在一个打磨器型的关键时刻，父母的言行，至关重要，一句做错了事却骂不到点子上的训斥，或是做错了，干脆就觉得自家孩子年纪太小，选择视而不见，最后可不就是害人害己害子女嘛。所以要赏罚分明，父母要学会给子女立规矩。仁义，理之本也。刑罚，理之末也。</p>]]></content>
    
    
    <categories>
      
      <category>文摘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑来</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>未相逢于最好的年纪，却给了对方最丰富的自己</title>
    <link href="/2020/10/21/%E6%80%BB%E6%9C%89%E4%B8%80%E5%A4%A9%E8%A6%81%E8%B7%9F%E6%89%80%E6%9C%89%E7%9A%84%E8%AE%B0%E5%BF%86%E7%9B%B8%E5%AE%89%E6%97%A0%E4%BA%8B%E6%8F%A1%E6%89%8B%E8%A8%80%E5%92%8C/"/>
    <url>/2020/10/21/%E6%80%BB%E6%9C%89%E4%B8%80%E5%A4%A9%E8%A6%81%E8%B7%9F%E6%89%80%E6%9C%89%E7%9A%84%E8%AE%B0%E5%BF%86%E7%9B%B8%E5%AE%89%E6%97%A0%E4%BA%8B%E6%8F%A1%E6%89%8B%E8%A8%80%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p>我时常想起，曾在我生命中出现的姑娘们。她们无论在当时还是记忆里，都美好得一塌糊涂，优秀得让人目眩神迷。现如今，她们一定更漂亮、更从容、更丰富了，一定遇到了更多好玩的人，演绎了更多精彩的故事。</p><p>一个曾短暂出现在我生活里的女孩子，订婚了。我的兄弟，爱一个姑娘两年半，最后收获了她跟他人订婚的“喜讯”。我常跟他说，那个人永远活在时间里了，你把她拉不出来，自己也回不去，就这样吧，让她安静的留在那里吧。<br>她不会发福不会老去不会穿着职业套装高跟鞋不会带着家长里短柴油米醋的气息，她永远年轻永远漂亮穿着鲜艳长裙站在回忆里，对着你笑靥如花。</p><p><strong>这样难道不好吗？</strong></p><p>你总有一天要跟所有的记忆相安无事握手言和，那里面有她也有你，有她的青春也有你的年华。让它们留在那里吧。生活里每天都有相聚别离，号啕或欢欣。<br>如果最初相识的姑娘注定无法走到最后，你会依然选择相遇在年少？还是在看遍春花夏月秋风冬雪后遇到她携手走进余下的旅途？这似乎是个不值得一提的问题，几乎所有人都喜欢“地老天荒”这样的词汇吧。</p><p>但真的有那么简单吗？问题的关键在于，你想开头还是收尾？你们在成熟稳重、理智从容、笑不露齿、工作稳定、职业套装高跟鞋、西装革履的28岁30岁相遇，气味相投性情相依相见恨晚唯怨月老一度瞎了眼，一段佳话就此开始，郎才女貌珠联璧合天造地设等祝福潮水一般涌来。像是个完美的故事。</p><p>她穿泛着光泽的高跟鞋、考究的套裙，妆容一丝不乱，带到你的朋友同事面前措辞得体，无可挑剔。她不会大喊大叫跟你无理取闹，不会要吃某家的小笼包让你穿越三条街道，不会很轻易的跟你赌气怀疑你是否跟其他女孩子有一腿。她包容体贴贤惠孝顺，入得厨房出得厅堂。</p><p>可是随着日复一日的平庸到来，某个回望的瞬间，内心是否会有隐隐的遗憾？<br>你是否想有一台时光机，回到她20岁22岁的年纪，在食堂、在图书馆、在主干道上，走上前去或礼貌或猥琐或忐忑的说一声：你好。那时候的她，穿着鲜艳的长裙素面朝天，穿着匡威白色帆布鞋，顶着刚洗完的湿漉漉头发冲去食堂打饭，一路上甩落无数男生的惊叹。</p><p>她漂亮、骄傲、聪明，会为了舍友的一句话而耿耿于怀，会为言情剧哭得稀里哗啦，会看到玩具店里的可爱公仔走不动路，会期待某个特别的节日收到男生们的玫瑰花。她没那么得体，还没学会滴水不漏笑不露齿，带到朋友面前会捂着嘴一个劲儿的傻笑。她穿匡威帆布鞋，也喜欢淘宝上淘来的便宜凉拖，她不太喜欢化妆，穿着T恤短裤就往宿舍楼下冲，在路边那家麻辣烫一边流汗一边大呼好吃，她会撒娇会胡搅蛮缠不讲理会为脑子里突然蹦出的疯狂念头兴奋不已……</p><p>那时候的你呢。没什么钱，脚上穿着攒了很久生活费买来的新球鞋，骑着拉风的山地车飞速驶过人群，在大排档跟一群狐朋狗友扯着政治足球和姑娘，面对递过来的啤酒瓶毫不犹豫一仰而尽，你那么年轻、那么张扬，脑子里满是自命不凡的想象，大声喊世界是我们的。你的发型土土的没有那么多发胶，还没有自己的第一套西装，你还没学会克制忍耐学会礼貌微笑，不高兴了随口就来一句：去他娘的。她路过操场，看到你打球的样子。汗水顺发梢滑过你红红彤彤的脸，你大声叫喊积极奔跑，仿佛身上有使不完的力气。</p><p>你们相遇。没那么理智包容，也很难总是做到相互理解，她没那么精致的漂亮，你也离成熟睿智差得很远，一个愣头小子，一个天真的丫头，就那么说着天长地久生死相依的誓言，你们以为世界会按照自己想象的编排，不懂得生活中永远不变的就是一直在变。你们会吵架、会分手、会伤害、会分头走路、会把彼此留在回忆里不断折磨，但是亲爱的，那是你们最好的年纪。</p><p>《艋舺》里说，“风往哪边吹，草就往哪边倒。年轻的时候我也以为自己是风，等到遍体鳞伤以后，才知道，原来我们都是草。”我们未必如草随风倒，却也只能这样，模模糊糊往前走。</p><p><strong>时间什么都安排好了。</strong></p><p>年轻时，总想看遍世间的风景，时不时涌出冒险的冲动，想拉着心爱的姑娘私奔，即刻就流浪到海涯天角。现在才明白，你什么风景都看不透，很可能也没有细水长流。你只能在一季季的春花夏月秋雨冬雪中，丈量自己生命的边界。有可能，姑娘都不会来，你就一个人走路，或缓或急，或愉悦或悲伤。</p><p>我时常也会烂俗的想，未来的姑娘呦，你到底什么样。你丰满还是消瘦活泼还是文静？你留俏皮的短发还是如瀑的长丝？你是否也喜欢那些瑰丽奇妙的文字，沉溺于光怪陆离的影像故事？你是否也扛过了狼血和庸俗成功学疯狂的侵蚀，依然带着对生活令人发指的热爱，坚持做一个有趣的人？</p><p>不管在28还是35岁相遇，拍落满身的风尘后，我们唯一能庆幸的，是彼此一定有很多好玩的故事、路途的见闻讲给对方听，那是一个个动人的传奇。</p><p>未相逢于最好的年纪，却给了对方最丰富的自己。</p><p>我不知道你会不会来，但仍大声唱着歌，走向你。</p>]]></content>
    
    
    <categories>
      
      <category>文摘</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
